apiVersion: batch/v1
kind: Job
metadata:
  name: postgres-init
spec:
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app: postgres-init
    spec:
      restartPolicy: OnFailure
      # Pod-level security context
      securityContext:
        runAsNonRoot: true
        runAsUser: 999
        fsGroup: 999
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: init-db
        image: postgres:16-alpine
        # Container-level security context
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          runAsNonRoot: true
          runAsUser: 999
        env:
        - name: PGHOST
          # This value will be patched per environment in overlay patches
          value: postgres-0.postgres
        - name: PGPORT
          value: "5432"
        - name: PGUSER
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_USER
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD
        - name: PGDATABASE
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_DB
        - name: DATADOG_PASSWORD
          valueFrom:
            secretKeyRef:
              name: datadog-postgres-credentials
              key: password
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "Waiting for PostgreSQL to be ready..."
          until pg_isready -h $PGHOST -p $PGPORT -U $PGUSER; do
            echo "Waiting for postgres..."
            sleep 2
          done

          echo "PostgreSQL is ready. Initializing database schema..."

          cat > /tmp/init.sql << 'EOSQL'
          -- Create users table
          CREATE TABLE IF NOT EXISTS users (
            id VARCHAR(255) PRIMARY KEY,
            name VARCHAR(255),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          -- Create burgers table
          CREATE TABLE IF NOT EXISTS burgers (
            id VARCHAR(255) PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            description TEXT,
            price DECIMAL(10, 2) NOT NULL,
            image VARCHAR(500),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          -- Create toppings table
          CREATE TABLE IF NOT EXISTS toppings (
            id VARCHAR(255) PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            category VARCHAR(100) NOT NULL,
            price DECIMAL(10, 2) NOT NULL,
            image VARCHAR(500),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );

          -- Create orders table
          CREATE TABLE IF NOT EXISTS orders (
            id VARCHAR(255) PRIMARY KEY,
            user_id VARCHAR(255) NOT NULL,
            burger_id VARCHAR(255) NOT NULL,
            topping_ids TEXT[],
            status VARCHAR(50) NOT NULL,
            total DECIMAL(10, 2) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
          );

          -- Create chats table for agent conversations
          CREATE TABLE IF NOT EXISTS chats (
            id VARCHAR(255) PRIMARY KEY,
            user_id VARCHAR(255) NOT NULL,
            title VARCHAR(500),
            mcp_session_id VARCHAR(255),
            messages JSONB DEFAULT '[]'::jsonb,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
          );

          -- Create indexes
          CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
          CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
          CREATE INDEX IF NOT EXISTS idx_chats_user_id ON chats(user_id);
          CREATE INDEX IF NOT EXISTS idx_burgers_name ON burgers(name);
          CREATE INDEX IF NOT EXISTS idx_toppings_category ON toppings(category);

          -- Seed burgers data (if empty)
          -- Image paths match files in packages/burger-api/data/images/
          -- These will be transformed to full URLs by burger-api using PUBLIC_BASE_URL
          INSERT INTO burgers (id, name, description, price, image) VALUES
            ('1', 'Classic American Cheeseburger', 'Juicy Angus beef patty topped with melted American cheese, crisp lettuce, tomato, red onion, and house special sauce on a toasted sesame bun.', 10.99, 'burger-pic-1.jpg'),
            ('2', 'Smoky BBQ Bacon Burger', 'Flame-grilled beef patty covered in smoky barbecue sauce, crispy bacon, cheddar cheese, onion rings, and sliced pickles on a brioche bun.', 12.49, 'burger-pic-2.jpg'),
            ('3', 'Spicy Jalapeño Fiesta Burger', 'Beef patty with pepper jack cheese, jalapeños, pickled red onions, chipotle mayo, and fresh avocado, served on a corn-dusted bun.', 11.99, 'burger-pic-3.jpg'),
            ('4', 'Mushroom Swiss Gourmet', 'Savory beef patty topped with sautéed mushrooms, Swiss cheese, caramelized onions, and garlic aioli on a potato roll.', 12.29, 'burger-pic-4.jpg'),
            ('5', 'Southern Fried Chicken Burger', 'Crispy buttermilk fried chicken breast, tangy coleslaw, spicy mayo, and dill pickles stacked on a soft bun.', 11.49, 'burger-pic-5.jpg'),
            ('6', 'Cali Veggie Supreme', 'Grilled veggie patty with melted provolone, fresh sprouts, tomato, red onion, cucumber, and herb aioli on a multigrain bun.', 10.79, 'burger-pic-6.jpg'),
            ('7', 'Spiced Chickpea Vegan Burger', 'Crispy spiced chickpea patty topped with vegan tzatziki, arugula, sliced tomato, pickled cucumbers, and red onion on a vegan bun.', 10.99, 'burger-pic-7.jpg'),
            ('8', 'Tokyo Teriyaki Fusion Burger', 'Seared beef patty glazed with teriyaki sauce, grilled pineapple, wasabi mayo, crisp lettuce, and sesame seeds on a toasted bun.', 12.59, 'burger-pic-8.jpg'),
            ('9', 'Mediterranean Lamb Burger', 'Juicy lamb patty with feta cheese, tzatziki, grilled eggplant, arugula, and tomato on a ciabatta roll.', 13.49, 'burger-pic-9.jpg'),
            ('10', 'Gluten-Free Avocado Turkey Burger', 'Grilled turkey patty topped with sliced avocado, pepper jack cheese, lettuce, tomato, and honey mustard, served on a gluten-free bun.', 11.99, 'burger-pic-10.jpg')
          ON CONFLICT (id) DO NOTHING;

          -- Seed toppings data (if empty)
          -- Image paths match files in packages/burger-api/data/images/
          -- These will be transformed to full URLs by burger-api using PUBLIC_BASE_URL
          INSERT INTO toppings (id, name, category, price, image) VALUES
            ('1', 'Iceberg Lettuce', 'vegetable', 0.50, 'topping-pic-1.jpg'),
            ('2', 'Tomato Slices', 'vegetable', 0.70, 'topping-pic-2.jpg'),
            ('3', 'Red Onion', 'vegetable', 0.40, 'topping-pic-3.jpg'),
            ('4', 'Pickles', 'vegetable', 0.40, 'topping-pic-4.jpg'),
            ('5', 'Grilled Mushrooms', 'vegetable', 0.80, 'topping-pic-5.jpg'),
            ('6', 'Jalapeños', 'vegetable', 0.50, 'topping-pic-6.jpg'),
            ('7', 'Bacon', 'meat', 1.20, 'topping-pic-7.jpg'),
            ('8', 'Beef Patty', 'meat', 2.50, 'topping-pic-8.jpg'),
            ('9', 'Chicken Breast', 'meat', 2.30, 'topping-pic-9.jpg'),
            ('10', 'Fried Egg', 'extras', 1.00, 'topping-pic-10.jpg'),
            ('11', 'Cheddar Cheese', 'cheese', 0.70, 'topping-pic-11.jpg'),
            ('12', 'Swiss Cheese', 'cheese', 0.80, 'topping-pic-12.jpg'),
            ('13', 'American Cheese', 'cheese', 0.60, 'topping-pic-13.jpg'),
            ('14', 'Blue Cheese Crumbles', 'cheese', 1.00, 'topping-pic-14.jpg'),
            ('15', 'Ketchup', 'sauce', 0.20, 'topping-pic-15.jpg'),
            ('16', 'Mayonnaise', 'sauce', 0.20, 'topping-pic-16.jpg'),
            ('17', 'Mustard', 'sauce', 0.20, 'topping-pic-17.jpg'),
            ('18', 'BBQ Sauce', 'sauce', 0.30, 'topping-pic-18.jpg'),
            ('19', 'Chipotle Mayo', 'sauce', 0.40, 'topping-pic-19.jpg'),
            ('20', 'Fried Onions', 'extras', 0.60, 'topping-pic-20.jpg'),
            ('21', 'Avocado', 'extras', 1.10, 'topping-pic-21.jpg'),
            ('22', 'Pineapple', 'extras', 0.90, 'topping-pic-22.jpg')
          ON CONFLICT (id) DO NOTHING;

          -- Create update timestamp trigger
          CREATE OR REPLACE FUNCTION update_updated_at_column()
          RETURNS TRIGGER AS '
          BEGIN
            NEW.updated_at = CURRENT_TIMESTAMP;
            RETURN NEW;
          END;
          ' language 'plpgsql';

          DROP TRIGGER IF EXISTS update_orders_updated_at ON orders;
          CREATE TRIGGER update_orders_updated_at
            BEFORE UPDATE ON orders
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();

          DROP TRIGGER IF EXISTS update_chats_updated_at ON chats;
          CREATE TRIGGER update_chats_updated_at
            BEFORE UPDATE ON chats
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();

          -- Note: The trigger function creation above may show escape warnings
          -- but will still work correctly. Triggers have been manually created.

          EOSQL

          echo "Executing SQL initialization script..."
          psql -f /tmp/init.sql

          echo "Setting up Datadog DBM monitoring..."

          # Create pg_stat_statements extension (required for DBM query metrics)
          psql -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;"

          # Create Datadog user using dynamic SQL with password from environment
          psql -c "DO \$\$
          BEGIN
            IF NOT EXISTS (SELECT FROM pg_catalog.pg_user WHERE usename = 'datadog') THEN
              EXECUTE format('CREATE USER datadog WITH PASSWORD %L', '${DATADOG_PASSWORD}');
              RAISE NOTICE 'Created datadog user';
            ELSE
              EXECUTE format('ALTER USER datadog WITH PASSWORD %L', '${DATADOG_PASSWORD}');
              RAISE NOTICE 'Updated datadog user password';
            END IF;
          END
          \$\$;"

          # Grant monitoring permissions
          psql -c "GRANT pg_monitor TO datadog;"
          psql -c "GRANT SELECT ON pg_stat_database TO datadog;"

          # Create schema for explain function
          psql -c "CREATE SCHEMA IF NOT EXISTS datadog;"
          psql -c "GRANT USAGE ON SCHEMA datadog TO datadog;"
          psql -c "GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA datadog TO datadog;"
          psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA datadog GRANT EXECUTE ON FUNCTIONS TO datadog;"

          # Create explain function for query samples (official Datadog version)
          psql -c "CREATE OR REPLACE FUNCTION datadog.explain_statement(
            l_query TEXT,
            OUT explain JSON
          )
          RETURNS SETOF JSON AS \$\$
          DECLARE
            curs REFCURSOR;
            plan JSON;
          BEGIN
            OPEN curs FOR EXECUTE pg_catalog.concat('EXPLAIN (FORMAT JSON) ', l_query);
            FETCH curs INTO plan;
            CLOSE curs;
            RETURN QUERY SELECT plan;
          END;
          \$\$ LANGUAGE plpgsql RETURNS NULL ON NULL INPUT SECURITY DEFINER;"

          # Grant execute permission on explain function
          psql -c "GRANT EXECUTE ON FUNCTION datadog.explain_statement(TEXT) TO datadog;"

          # Verify setup
          echo "Verifying Datadog user and permissions..."
          psql -c "SELECT usename, usesuper FROM pg_user WHERE usename = 'datadog';"
          psql -c "SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'datadog';"

          echo "Database initialization completed successfully!"
          echo "✓ Database schema and seed data initialized"
          echo "✓ Datadog DBM monitoring user configured"
