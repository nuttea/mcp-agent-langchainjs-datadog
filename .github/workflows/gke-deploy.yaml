name: Build and Deploy to GKE

on:
  push:
    branches:
      - main    # Deploy to dev
      - prod    # Deploy to prod
    # Note: No paths filter - workflow always runs to check for [force build] keyword
    # Change detection happens in detect-changes job

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - prod
      skip_build:
        description: 'Skip image build (use existing images)'
        required: false
        type: boolean
        default: false

env:
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ vars.GKE_CLUSTER }}
  GKE_ZONE: ${{ vars.GKE_ZONE }}
  GAR_LOCATION: ${{ vars.GAR_LOCATION }}
  GAR_REPOSITORY: ${{ vars.GAR_REPOSITORY }}

jobs:
  # Always build all packages on every push (simplified - no change detection)
  detect-changes:
    name: Detect Changed Packages
    runs-on: ubuntu-latest
    outputs:
      agent-api: 'true'
      agent-webapp: 'true'
      burger-api: 'true'
      burger-mcp: 'true'
      burger-webapp: 'true'
      any-changed: 'true'
    steps:
      - name: Always build all packages
        run: |
          echo "✅ Building all packages on every push"
          echo "This workflow now always builds all packages without change detection"

  # Build Docker images
  # Dev: Always build on push to main (uses :latest tag)
  # Prod: Only build changed packages on push to prod (uses :commit-sha tag)
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    if: |
      (github.ref == 'refs/heads/main') ||
      (github.ref == 'refs/heads/prod' && needs.detect-changes.outputs.any-changed == 'true') ||
      github.event.inputs.skip_build != 'true'
    permissions:
      contents: read
      id-token: write
    strategy:
      matrix:
        package:
          - agent-api
          - agent-webapp
          - burger-api
          - burger-mcp
          - burger-webapp
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if this package should build
        id: should-build
        run: |
          BRANCH="${{ github.ref }}"
          PACKAGE_CHANGED="${{ needs.detect-changes.outputs[matrix.package] }}"

          # Dev (main branch): Always build all packages
          if [[ "${BRANCH}" == "refs/heads/main" ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "✓ Dev build - building all packages"
          # Prod: Only build if package changed
          elif [[ "${BRANCH}" == "refs/heads/prod" ]] && [[ "${PACKAGE_CHANGED}" == "true" ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "✓ Prod build - package changed"
          else
            echo "build=false" >> $GITHUB_OUTPUT
            echo "⊘ Skipping build - no changes in prod"
          fi

      - name: Set up Docker Buildx
        if: steps.should-build.outputs.build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Authenticate to Google Cloud
        if: steps.should-build.outputs.build == 'true'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        if: steps.should-build.outputs.build == 'true'
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for GAR
        if: steps.should-build.outputs.build == 'true'
        run: |
          gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

      - name: Generate image tags
        if: steps.should-build.outputs.build == 'true'
        id: tags
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_BASE="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ matrix.package }}"

          # Tag with commit hash (primary identifier)
          echo "commit_tag=${IMAGE_BASE}:${SHORT_SHA}" >> $GITHUB_OUTPUT

          # Tag with branch name
          BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/} | sed 's/\//-/g')
          echo "branch_tag=${IMAGE_BASE}:${BRANCH_NAME}" >> $GITHUB_OUTPUT

          # Tag with latest if main branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "latest_tag=${IMAGE_BASE}:latest" >> $GITHUB_OUTPUT
          fi

          echo "image_base=${IMAGE_BASE}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        if: steps.should-build.outputs.build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: packages/${{ matrix.package }}/Dockerfile
          push: true
          tags: |
            ${{ steps.tags.outputs.commit_tag }}
            ${{ steps.tags.outputs.branch_tag }}
            ${{ steps.tags.outputs.latest_tag }}
          platforms: linux/amd64
          no-cache: true

      - name: Output image details
        if: steps.should-build.outputs.build == 'true'
        run: |
          echo "Built and pushed images:"
          echo "- ${{ steps.tags.outputs.commit_tag }}"
          echo "- ${{ steps.tags.outputs.branch_tag }}"
          echo "- ${{ steps.tags.outputs.latest_tag }}"

  # Deploy to environment
  deploy:
    name: Deploy to ${{ matrix.environment }}
    runs-on: ubuntu-latest
    needs: [detect-changes, build-images]
    if: always() && (needs.build-images.result == 'success' || needs.build-images.result == 'skipped')
    permissions:
      contents: read
      id-token: write
    strategy:
      matrix:
        include:
          - branch: main
            environment: dev
          - branch: prod
            environment: prod
    environment:
      name: ${{ matrix.environment }}
      url: https://${{ matrix.environment == 'prod' && 'platform-engineering-demo.dev' || 'dev.platform-engineering-demo.dev' }}
    steps:
      - name: Check if deployment should proceed
        id: should-deploy
        run: |
          SHOULD_DEPLOY="false"

          # Check if branch matches environment
          if [[ "${{ github.ref }}" == "refs/heads/${{ matrix.branch }}" ]]; then
            SHOULD_DEPLOY="true"
            echo "✓ Branch ${{ matrix.branch }} matches, deploying to ${{ matrix.environment }}"
          fi

          # Or if manual workflow dispatch specified this environment
          if [[ "${{ github.event.inputs.environment }}" == "${{ matrix.environment }}" ]]; then
            SHOULD_DEPLOY="true"
            echo "✓ Manual deployment to ${{ matrix.environment }} requested"
          fi

          echo "should_deploy=${SHOULD_DEPLOY}" >> $GITHUB_OUTPUT

          if [[ "${SHOULD_DEPLOY}" == "false" ]]; then
            echo "⊘ Skipping deployment: branch ${{ github.ref }} does not match ${{ matrix.environment }}"
            exit 0
          fi

      - name: Checkout code
        if: steps.should-deploy.outputs.should_deploy == 'true'
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        if: steps.should-deploy.outputs.should_deploy == 'true'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        if: steps.should-deploy.outputs.should_deploy == 'true'
        uses: google-github-actions/setup-gcloud@v2

      - name: Install gke-gcloud-auth-plugin
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          gcloud components install gke-gcloud-auth-plugin

      - name: Get GKE credentials
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --zone=${{ env.GKE_ZONE }} \
            --project=${{ env.GCP_PROJECT_ID }}

      - name: Install Kustomize
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/

      - name: Generate secrets
        if: steps.should-deploy.outputs.should_deploy == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
          POSTGRES_USER: ${{ vars.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ vars.POSTGRES_DB }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          ./k8s/scripts/generate-secrets.sh ${{ matrix.environment }}

      - name: Update image tags in Kustomize
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_BASE="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}"
          ENV=${{ matrix.environment }}

          cd k8s/overlays/${ENV}

          # Strategy:
          # - Dev: Always use :latest (updated by every push to main)
          # - Prod: Use :commit-sha (specific version from PR merge)
          if [[ "${ENV}" == "dev" ]]; then
            echo "✓ Dev deployment - using :latest tags (always pulls newest build)"

            # Update to use latest tag (which is continuously updated)
            kustomize edit set image \
              gcr.io/${{ env.GCP_PROJECT_ID }}/agent-api=${IMAGE_BASE}/agent-api:latest \
              gcr.io/${{ env.GCP_PROJECT_ID }}/agent-webapp=${IMAGE_BASE}/agent-webapp:latest \
              gcr.io/${{ env.GCP_PROJECT_ID }}/burger-api=${IMAGE_BASE}/burger-api:latest \
              gcr.io/${{ env.GCP_PROJECT_ID }}/burger-mcp=${IMAGE_BASE}/burger-mcp:latest \
              gcr.io/${{ env.GCP_PROJECT_ID }}/burger-webapp=${IMAGE_BASE}/burger-webapp:latest

          elif [[ "${ENV}" == "prod" ]]; then
            echo "✓ Prod deployment - using commit SHA: ${SHORT_SHA}"

            # Update to use specific commit hash for immutable deployments
            kustomize edit set image \
              gcr.io/${{ env.GCP_PROJECT_ID }}/agent-api=${IMAGE_BASE}/agent-api:${SHORT_SHA} \
              gcr.io/${{ env.GCP_PROJECT_ID }}/agent-webapp=${IMAGE_BASE}/agent-webapp:${SHORT_SHA} \
              gcr.io/${{ env.GCP_PROJECT_ID }}/burger-api=${IMAGE_BASE}/burger-api:${SHORT_SHA} \
              gcr.io/${{ env.GCP_PROJECT_ID }}/burger-mcp=${IMAGE_BASE}/burger-mcp:${SHORT_SHA} \
              gcr.io/${{ env.GCP_PROJECT_ID }}/burger-webapp=${IMAGE_BASE}/burger-webapp:${SHORT_SHA}
          fi

      - name: Update Datadog UST version labels
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          ENV=${{ matrix.environment }}

          # Always use commit SHA for VERSION tracking
          # This enables correlating Datadog traces/logs/metrics to exact code version
          echo "✓ Setting VERSION to commit SHA: ${SHORT_SHA}"

          # Update version-labels.yaml patch with commit SHA
          # Replace the default version placeholder with actual commit SHA
          sed -i.bak "s/version: ${ENV}-local/version: ${SHORT_SHA}/g" \
            k8s/overlays/${ENV}/patches/version-labels.yaml

          # Also update VERSION environment variable value
          # Quote the value to ensure it's treated as a string, not a number
          sed -i.bak "s/value: ${ENV}-local/value: \"${SHORT_SHA}\"/g" \
            k8s/overlays/${ENV}/patches/version-labels.yaml

          echo "Updated version labels:"
          grep -E "version:|value:" k8s/overlays/${ENV}/patches/version-labels.yaml | head -10

      - name: Deploy with Canary Strategy
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          ENV=${{ matrix.environment }}
          NAMESPACE="mcp-agent-${ENV}"
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)

          echo "Deploying to ${ENV} environment (namespace: ${NAMESPACE})"

          # Apply base infrastructure (ConfigMaps, Services, etc.)
          kubectl apply -k k8s/overlays/${ENV}

          # For production, use canary deployment strategy
          if [[ "${ENV}" == "prod" ]]; then
            echo "Using canary deployment strategy for production"

            # Get list of deployments
            DEPLOYMENTS=$(kubectl get deployments -n ${NAMESPACE} -o name | grep -v canary || true)

            for DEPLOYMENT in ${DEPLOYMENTS}; do
              DEPLOY_NAME=$(echo ${DEPLOYMENT} | cut -d'/' -f2)

              echo "Starting canary deployment for ${DEPLOY_NAME}"

              # Create canary deployment (10% of replicas)
              kubectl get deployment ${DEPLOY_NAME} -n ${NAMESPACE} -o yaml | \
                sed "s/${DEPLOY_NAME}/${DEPLOY_NAME}-canary/g" | \
                kubectl apply -f -

              # Scale canary to 1 replica
              kubectl scale deployment ${DEPLOY_NAME}-canary -n ${NAMESPACE} --replicas=1

              # Wait for canary to be ready
              kubectl rollout status deployment/${DEPLOY_NAME}-canary -n ${NAMESPACE} --timeout=5m

              # Check canary health (wait 30 seconds)
              echo "Canary deployed, monitoring for 30 seconds..."
              sleep 30

              # Check if canary pods are healthy
              CANARY_READY=$(kubectl get deployment ${DEPLOY_NAME}-canary -n ${NAMESPACE} -o jsonpath='{.status.readyReplicas}')
              if [[ "${CANARY_READY}" -lt 1 ]]; then
                echo "Canary deployment failed health check. Rolling back..."
                kubectl delete deployment ${DEPLOY_NAME}-canary -n ${NAMESPACE}
                exit 1
              fi

              echo "Canary healthy, proceeding with full rollout..."

              # Update main deployment
              kubectl set image deployment/${DEPLOY_NAME} -n ${NAMESPACE} \
                ${DEPLOY_NAME}=${GAR_LOCATION}-docker.pkg.dev/${GCP_PROJECT_ID}/${GAR_REPOSITORY}/${DEPLOY_NAME}:${SHORT_SHA}

              # Wait for main deployment rollout
              kubectl rollout status deployment/${DEPLOY_NAME} -n ${NAMESPACE} --timeout=5m

              # Delete canary deployment
              kubectl delete deployment ${DEPLOY_NAME}-canary -n ${NAMESPACE}

              echo "Canary deployment completed for ${DEPLOY_NAME}"
            done
          else
            # For dev, use standard rolling update
            echo "Using standard rolling update for dev environment"
            kubectl rollout restart deployment -n ${NAMESPACE}
          fi

      - name: Verify deployment
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          ENV=${{ matrix.environment }}
          NAMESPACE="mcp-agent-${ENV}"

          echo "Verifying deployments in ${NAMESPACE}..."
          kubectl get deployments -n ${NAMESPACE}
          kubectl get pods -n ${NAMESPACE}

          # Check if all deployments are ready
          kubectl wait --for=condition=available --timeout=300s \
            deployment --all -n ${NAMESPACE} || {
            echo "❌ Deployment failed! Checking pod status..."
            kubectl get pods -n ${NAMESPACE} -o wide

            # Check for pods in CrashLoopBackOff or Error state
            FAILED_PODS=$(kubectl get pods -n ${NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded -o jsonpath='{.items[*].metadata.name}')

            if [[ -n "${FAILED_PODS}" ]]; then
              echo "Failed pods: ${FAILED_PODS}"
              for pod in ${FAILED_PODS}; do
                echo "==== Logs for ${pod} ===="
                kubectl logs -n ${NAMESPACE} ${pod} --tail=50 || echo "Could not fetch logs for ${pod}"
                echo ""
                echo "==== Events for ${pod} ===="
                kubectl describe pod -n ${NAMESPACE} ${pod} | grep -A 20 "Events:"
                echo ""
              done
            fi

            exit 1
          }

          echo "✅ All deployments are ready"

      - name: Run smoke tests
        if: steps.should-deploy.outputs.should_deploy == 'true'
        run: |
          ENV=${{ matrix.environment }}

          if [[ "${ENV}" == "prod" ]]; then
            AGENT_URL="https://platform-engineering-demo.dev"
            BURGER_API_URL="https://burger-api.platform-engineering-demo.dev"
          else
            AGENT_URL="https://dev.platform-engineering-demo.dev"
            BURGER_API_URL="https://burger-api-dev.platform-engineering-demo.dev"
          fi

          echo "Running smoke tests..."

          # Test burger-api health
          curl -f ${BURGER_API_URL}/api/burgers | jq '.[] | .name' | head -3

          echo "Smoke tests passed!"

      - name: Notify deployment status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "✅ Deployment to ${{ matrix.environment }} successful!"
          else
            echo "❌ Deployment to ${{ matrix.environment }} failed!"
          fi

  # Cleanup old images
  cleanup:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Clean up old images (keep last 10)
        run: |
          PACKAGES="agent-api agent-webapp burger-api burger-mcp burger-webapp"

          for PACKAGE in ${PACKAGES}; do
            echo "Cleaning up old images for ${PACKAGE}..."

            # Get all image digests sorted by creation time
            gcloud artifacts docker images list \
              ${GAR_LOCATION}-docker.pkg.dev/${GCP_PROJECT_ID}/${GAR_REPOSITORY}/${PACKAGE} \
              --format="get(digest)" \
              --sort-by="~createTime" \
              --limit=1000 | tail -n +11 | while read DIGEST; do

              if [[ ! -z "${DIGEST}" ]]; then
                echo "Deleting ${PACKAGE}@${DIGEST}"
                gcloud artifacts docker images delete \
                  ${GAR_LOCATION}-docker.pkg.dev/${GCP_PROJECT_ID}/${GAR_REPOSITORY}/${PACKAGE}@${DIGEST} \
                  --quiet || true
              fi
            done
          done
